
任宇翔
2023春-操作系统
提交评测
2023-05-22 21:28:23
Lab 5-2 Extra: Symbolic link
准备工作
请在自动初始化分支后，在开发机依次执行以下命令：

$ cd ~/学号
$ git fetch
$ git checkout lab5-2-extra
初始化的 lab5-2-extra 分支基于课下完成的 lab5 分支，并且在 tests 目录下添加了 lab5_symlink 样例测试目录。

题目背景 & 预备知识
在 Linux 系统中，符号链接（Symbolic link）是一种特殊的文件类型，用来表示指向另一个文件路径的“指针”，类似于 Windows 系统中的快捷方式。如果你对符号链接的知识有所了解，可以跳过这一节的内容。

在磁盘上，符号链接的物理内容为其指向的文件的路径。符号链接本身可能会指向另一个符号链接。当我们使用 open() 函数打开一个符号链接的时候，实际上打开的是其最终指向的文件，返回最终指向的文件的文件描述符。

同学们可以在 Linux 终端使用 ln -s <目标文件> <链接文件的路径> 命令来创建一个符号链接。同学们可以在开发机中依次执行下面的命令来了解符号链接的概念。

$ mkdir ~/test
$ cd ~/test
$ echo 2023 > target # 创建名为 target 的文件，内容为 2023
$ ln -s target symlink # 创建一个符号链接 symlink，指向 target
$ ls -l # 可以展示当前目录下链接文件的相关信息，可以看到输出显示了 symlink -> target，这表明 symlink 指向 target
$ cat symlink # 看看命令输出了什么
继续在这个目录下创建一个名为 test_open.c 的文件，写入下面的代码。

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
	int fd = open("symlink", 0);
	char buf[8];
	int len = read(fd, buf, sizeof(buf) - 1);
	buf[len] = '\0';
	printf("%s", buf);
	return 0;
}
使用命令 gcc test_open.c && ./a.out 来编译运行该程序，可以看到输出为2023，即 target 文件的内容。

题目描述 & 题目要求
我们需要拓展现有的文件系统，使其能够打开符号链接最终指向的文件。

符号链接指向的路径（即符号链接文件的内容）满足下面几个要求：

符号链接指向的路径一定是绝对路径（mos 目前也只支持绝对路径的解析）。

符号链接指向的路径对应的文件要么是普通文件，要么是最终指向普通文件的符号链接。这蕴含了以下两点：

符号链接不会指向一个目录，因此一个路径的各部分中的目录都不会是符号链接；

符号链接可能指向的是一个符号链接，这个符号链接可能指向的也是一个符号链接，以此类推，但最终一定会指向一个普通文件。例如，以下的符号链接关系是合法的。

链接文件 /lib/a
链接文件 /my/b
普通文件 /real
评测点满足要求：

符号链接最终指向的普通文件一定存在。不要求进行错误处理。
链接关系不会产生环，例如，不会出现 a 指向 b，且 b 指向 a 的情况。
文件名的长度和路径长度满足 MOS 的要求，即文件名长度不会超过 MAXNAMELEN，路径长度不会超过 MAXPATHLEN（这两个宏定义在 user/include/fs.h 中）。
我们需要实现的内容
在 user/include/fs.h 中定义新的文件类型，即 #define FTYPE_LNK 2（不要使用其他数字作为链接文件的枚举编号）。

修改 tools/fsformat.c，使得 fsformat 工具在写入文件时根据传入的各个文件的类型来决定写入磁盘镜像的文件的类型（FTYPE_LNK、FTYPE_DIR 或 FTYPE_REG）。以下是一种修改的思路：

将 main() 函数中调用的 stat() 函数改为 lstat()（参数不用改变）。stat() 或 lstat() 的作用都是将一个文件的相关信息储存在 statbuf 结构体中。它们的区别在于：stat() 函数会跟踪链接，会解析链接最终指向的文件；而lstat() 不会跟踪链接，直接解析链接文件本身。而我们需要读取链接文件本身的信息，所以需要使用 lstat() 函数替换 stat() 函数（直接改函数名即可，这两个函数都是 Linux 的库函数）。
可以仿照 write_file() 函数编写 write_symlink() 函数，实现向磁盘镜像写入符号链接文件的功能。你可以调用 Linux 库函数 int readlink(char *pathname, char *buf, int bufsiz) 来读取一个链接文件指向的目标路径（这个函数将路径 pathname 处的符号链接指向的目标路径写入 buf 指向的缓冲区，最多写入 bufsiz 个字节，返回值是写入的字节数量。详细说明可以在开发机中使用 man 2 readlink 命令查阅）。一种可能的实现框架如下所示：
void write_symlink(struct File *dirf, const char *path) {
	struct File *target = create_file(dirf);
	// Your code here: 使用 readlink() 函数读取链接文件指向的路径，将其写入到下一个可用的磁盘块

	const char *fname = strrchr(path, '/');
	if (fname) {
		fname++;
	} else {
		fname = path;
	}
	// Your code here: 设置链接文件的文件名、大小（指向路径的字符串的长度）、类型属性

	save_block_link(target, 0, next_block(BLOCK_DATA));
}
修改 main() 函数，在 if else 结构中增加一个分支，调用你编写的 write_symlink() 函数，使其不仅支持目录和普通文件的读取，还可以支持符号链接文件的读取。可以使用 S_ISLNK(stat_buf.stmode) 判断命令行参数对应的文件是否为符号链接。
修改 write_directory()函数，在 if else 结构中增加一个分支，调用你编写的 write_symlink() 函数，使其不仅支持目录和普通文件的读取，还可以支持符号链接文件的读取。结构体 dirent 的成员变量 d_type 可能会用到以下取值：DT_DIR（目录）、DT_LNK（符号链接）、DT_REG（普通文件）。
修改文件系统的实现，使其满足：用户程序使用 open() 函数打开一个符号链接文件的时候，实际上打开的是其最终指向的文件，返回最终指向的文件的文件描述符。被打开的文件可以正常地读写，就像直接打开了最终指向的文件一样。

样例输出 & 本地测试
我们的样例位于 tests/lab5_symlink 目录下。

最终写入磁盘镜像文件的目录树如下所示：

/
├── lib
│   └── a
├── my
│   └── b
└── real
其中，/lib/a 是符号链接文件，指向 /my/b，/my/b 是符号链接文件，指向 /real，/real 是普通文件，其文件内容是 Hello, world!。

请注意，包含该目录树的 rootfs 目录会在构建测试样例时被创建。如果希望查看该目录结构，你可以在 tests/lab5_symlink 目录下使用 make rootfs 命令，以提前生成根文件系统 tests/lab5_symlink/rootfs。你可以查看 tests/lab5_symlink/Makefile 的内容来了解上述的目录树是如何创建的。

可以使用 ls -l 命令对链接文件指向的路径进行预览。请注意，你在 Linux 环境下是无法打开这些链接文件的，因为它们指向的是 mos 中的绝对路径，在 Linux 开发机中并不存在。

symlink_check.c 文件是测试用户程序的源代码，内容如下所示：

#include <lib.h>

static char *path = "/lib/a";

int main() {
	int fd = open(path, O_RDONLY);
	if (fd < 0) {
		user_panic("failed to open %s, return value: %d", path, fd);
	}
	char buf[16];
	int len = read(fd, buf, sizeof(buf) - 1);
	buf[len] = '\0';
	debugf("File content: %s\n", buf);
	close(fd);
	return 0;
}
程序应当能够正确地读取文件的内容。在操作系统运行正确的情况下输出包含这一行内容，则表明通过样例。

File content: Hello, world!
你可以在 ~/学号 目录下使用 make test lab=5_symlink && make run 在本地以调试模式测试上述样例。

你可以使用 MOS_PROFILE=release make test lab=5_symlink && make run 在本地开启优化测试上述样例。评测机在评测时会开启优化。

你也可以修改 tests/lab5_symlink/check_symlink.c 和 tests/lab5_symlink/Makefile，自行编写测试代码进行测试。

提交评测 & 评测标准
请在开发机中执行下列命令后，在课程网站上提交评测。

$ cd ~/学号
$ git add -A
$ git commit -m "message"  # 请将 message 改为有意义的信息
$ git push
在线评测时，所有的 .mk 文件、所有的 Makefile 文件、init/init.c 以及 tests/ 和 tools/ 目录下的所有文件都可能被替换为标准版本，因此请同学们在本地开发时，不要在这些文件中编写实际功能所依赖的代码。

测试点和分数说明如下：

测试点序号	评测内容	分数
1	样例	10
2	链接文件指向的文件一定是普通文件，并对打开文件进行读写测试	40
3	存在多级链接，可能链接到任意路径的文件或链接，并对打开文件进行读写测试	30
4	存在多级链接，可能链接到任意路径的文件或链接，并对打开文件进行读写测试	20